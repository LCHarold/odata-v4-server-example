{"version":3,"sources":["IndexedDbProvider.js","src/Types/StorageProviders/IndexedDB/IndexedDBConverter.js","src/Types/StorageProviders/IndexedDB/IndexedDBStorageProvider.js","src/Types/StorageProviders/IndexedDB/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","$data","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"_dereq_","_interopRequireDefault","obj","__esModule","default","_core","_core2","IndexedDBConverter","fromDb","$data.Byte","Container","proxyConverter","$data.SByte","$data.Decimal","$data.Float","$data.Int16","$data.Int64","$data.Integer","$data.Int32","$data.Number","$data.Date","$data.DateTimeOffset","$data.Time","$data.String","$data.Boolean","$data.Blob","b","convertTo","Blob","$data.Array","arr","undefined","Array","$data.Object","$data.Guid","parseGuid","toString","$data.GeographyPoint","GeographyPoint","$data.GeographyLineString","GeographyLineString","$data.GeographyPolygon","GeographyPolygon","$data.GeographyMultiPoint","GeographyMultiPoint","$data.GeographyMultiLineString","GeographyMultiLineString","$data.GeographyMultiPolygon","GeographyMultiPolygon","$data.GeographyCollection","GeographyCollection","$data.GeometryPoint","GeometryPoint","$data.GeometryLineString","GeometryLineString","$data.GeometryPolygon","GeometryPolygon","$data.GeometryMultiPoint","GeometryMultiPoint","$data.GeometryMultiLineString","GeometryMultiLineString","$data.GeometryMultiPolygon","GeometryMultiPolygon","$data.GeometryCollection","GeometryCollection","toDb","JSON","parse","stringify","jaydata/core",2,"_typeof","Symbol","iterator","constructor","Class","StorageProviderBase","cfg","ctxInstance","indexedDB","__global","webkitIndexedDB","mozIndexedDB","msIndexedDB","IDBRequest","webkitIDBRequest","mozIDBRequest","msIDBRequest","IDBTransaction","webkitIDBTransaction","mozIDBTransaction","msIDBTransaction","IDBTransactionType","READ_ONLY","READ_WRITE","VERSIONCHANGE","IDBKeyRange","webkitIDBKeyRange","mozIDBKeyRange","msIDBKeyRange","IDBDatabaseException","webkitIDBDatabaseException","mozIDBDatabaseException","msIDBDatabaseException","IDBOpenDBRequest","webkitIDBOpenDBRequest","mozIDBOpenDBRequest","msIDBOpenDBRequest","newVersionAPI","IDBFactory","prototype","deleteDatabase","sequenceStore","SqlCommands","context","providerConfiguration","typeSystem","extend","databaseName","defaults","defaultDatabaseName","version","dbCreation","storageProviders","DbCreationType","DropTableIfChanged","memoryOperations","_setupExtensionMethods","originalContext","getType","supportedBinaryOperators","value","equal","mapTo","dataType","Boolean","notEqual","equalTyped","notEqualTyped","greaterThan","greaterThanOrEqual","lessThan","lessThenOrEqual","or","and","supportedSetOperations","toArray","forEach","enumerable","writable","supportedFieldOperations","supportedUnaryOperators","idbRequest","idbTran","idbOpenDBRequest","setCallbacks","callbackSettings","Guard","raise","Exception","supportedDataTypes","Integer","Number","Date","String","Object","Guid","Byte","SByte","Decimal","Float","Int16","Int32","Int64","Time","DateTimeOffset","fieldConverter","supportedAutoincrementKeys","createGuid","_getObjectStoreDefinition","setDefinition","contextStore","storeName","TableName","keyFields","PhysicalType","memberDefinitions","getKeyProperties","error","name","some","memDef","computed","typeName","resolveName","type","console","log","_getObjectStoreDefinitions","objectStoreDefinitions","_storageModel","objectStoreDefinition","push","_oldCreateDB","setVersionTran","definitions","onready","db","onversionchange","event","target","close","_createDB","oncomplete","dropIfExists","objectStoreNames","contains","deleteObjectStore","storeDef","settings","keyPath","autoIncrement","key","createObjectStore","_hasDbChanges","dropTabes","isOriginal","onupgradeneeded","result","hasTableChanges","DropAllExistingTables","initializeStore","callBack","PromiseHandlerBase","createCallbackSettings","initializeMemoryStore","success","open","onsuccess","setVersion","parseInt","onerror","arguments","onblocked","onabort","operationProvider","onReady","storageProvider","_initializeStore","initDb","ret","newSequences","createStore","osParam","keySettings","_getKeySettings","openCallbacks","store","transaction","objectStore","clear","item","versionRequest","evt","executeQuery","query","entitySet","getEntitySetFromElementType","defaultType","tableName","dataSource","rawDataList","expression","nodeType","Expressions","ExpressionType","Count","cnt","modelBinderCompiler","createModelBinderConfigCompiler","Visit","openCursor","cursor","count","keys","getPublicMappedProperties","saveChanges","changedItems","saveNextIndependentBlock","independentBlocks","KeySettingsCache","cache","getSettingsForItem","data","fullName","hasOwnProperty","getStorageModel","currentBlock","shift","storesObj","convertedItems","map","physicalData","elementType","keyValue","inverseProperty","concurrencyMode","entityState","EntityState","Added","changedProperties","def","stores","tran","errorCode","ABORT_ERR","ksCache","itemKeys","cursorAction","action","only","ex","abort","add","Deleted","Modified","update","Unchanged","buildIndependentBlocks","_compile","sqlText","createIndexedDBCompiler","compile","isSupported","get","set","indexedDb","IndexedDBStorageProvider","registerProvider",3,"defineProperty","_IndexedDBConverter","_IndexedDBStorageProvider","./IndexedDBConverter.js","./IndexedDBStorageProvider.js"],"mappings":"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","file":"IndexedDbProvider.min.js","sourcesContent":["﻿// JayData 1.5.1 CTP\r\n// Dual licensed under MIT and GPL v2\r\n// Copyright JayStack Technologies (http://jaydata.org/licensing)\r\n//\r\n// JayData is a standards-based, cross-platform Javascript library and a set of\r\n// practices to access and manipulate data from various online and offline sources.\r\n//\r\n// Credits:\r\n//     Hajnalka Battancs, Dániel József, János Roden, László Horváth, Péter Nochta\r\n//     Péter Zentai, Róbert Bónay, Szabolcs Czinege, Viktor Borza, Viktor Lázár,\r\n//     Zoltán Gyebrovszki, Gábor Dolla\r\n//\r\n// More info: http://jaydata.org\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.$data = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.IndexedDBConverter = {\n    fromDb: {\n        '$data.Byte': _core2.default.Container.proxyConverter,\n        '$data.SByte': _core2.default.Container.proxyConverter,\n        '$data.Decimal': _core2.default.Container.proxyConverter,\n        '$data.Float': _core2.default.Container.proxyConverter,\n        '$data.Int16': _core2.default.Container.proxyConverter,\n        '$data.Int64': _core2.default.Container.proxyConverter,\n        '$data.Integer': _core2.default.Container.proxyConverter,\n        '$data.Int32': _core2.default.Container.proxyConverter,\n        '$data.Number': _core2.default.Container.proxyConverter,\n        '$data.Date': _core2.default.Container.proxyConverter,\n        '$data.DateTimeOffset': _core2.default.Container.proxyConverter,\n        '$data.Time': _core2.default.Container.proxyConverter,\n        '$data.String': _core2.default.Container.proxyConverter,\n        '$data.Boolean': _core2.default.Container.proxyConverter,\n        '$data.Blob': function $dataBlob(b) {\n            return b ? _core2.default.Container.convertTo(b, _core2.default.Blob) : b;\n        },\n        '$data.Array': function $dataArray(arr) {\n            if (arr === undefined) {\n                return new _core2.default.Array();\n            }return arr;\n        },\n        '$data.Object': _core2.default.Container.proxyConverter,\n        \"$data.Guid\": function $dataGuid(g) {\n            return g ? _core2.default.parseGuid(g).toString() : g;\n        },\n        '$data.GeographyPoint': function $dataGeographyPoint(g) {\n            if (g) {\n                return new _core2.default.GeographyPoint(g);\n            }return g;\n        },\n        '$data.GeographyLineString': function $dataGeographyLineString(g) {\n            if (g) {\n                return new _core2.default.GeographyLineString(g);\n            }return g;\n        },\n        '$data.GeographyPolygon': function $dataGeographyPolygon(g) {\n            if (g) {\n                return new _core2.default.GeographyPolygon(g);\n            }return g;\n        },\n        '$data.GeographyMultiPoint': function $dataGeographyMultiPoint(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiPoint(g);\n            }return g;\n        },\n        '$data.GeographyMultiLineString': function $dataGeographyMultiLineString(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiLineString(g);\n            }return g;\n        },\n        '$data.GeographyMultiPolygon': function $dataGeographyMultiPolygon(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiPolygon(g);\n            }return g;\n        },\n        '$data.GeographyCollection': function $dataGeographyCollection(g) {\n            if (g) {\n                return new _core2.default.GeographyCollection(g);\n            }return g;\n        },\n        '$data.GeometryPoint': function $dataGeometryPoint(g) {\n            if (g) {\n                return new _core2.default.GeometryPoint(g);\n            }return g;\n        },\n        '$data.GeometryLineString': function $dataGeometryLineString(g) {\n            if (g) {\n                return new _core2.default.GeometryLineString(g);\n            }return g;\n        },\n        '$data.GeometryPolygon': function $dataGeometryPolygon(g) {\n            if (g) {\n                return new _core2.default.GeometryPolygon(g);\n            }return g;\n        },\n        '$data.GeometryMultiPoint': function $dataGeometryMultiPoint(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiPoint(g);\n            }return g;\n        },\n        '$data.GeometryMultiLineString': function $dataGeometryMultiLineString(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiLineString(g);\n            }return g;\n        },\n        '$data.GeometryMultiPolygon': function $dataGeometryMultiPolygon(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiPolygon(g);\n            }return g;\n        },\n        '$data.GeometryCollection': function $dataGeometryCollection(g) {\n            if (g) {\n                return new _core2.default.GeometryCollection(g);\n            }return g;\n        }\n    },\n    toDb: {\n        '$data.Byte': _core2.default.Container.proxyConverter,\n        '$data.SByte': _core2.default.Container.proxyConverter,\n        '$data.Decimal': _core2.default.Container.proxyConverter,\n        '$data.Float': _core2.default.Container.proxyConverter,\n        '$data.Int16': _core2.default.Container.proxyConverter,\n        '$data.Int64': _core2.default.Container.proxyConverter,\n        '$data.Integer': _core2.default.Container.proxyConverter,\n        '$data.Int32': _core2.default.Container.proxyConverter,\n        '$data.Number': _core2.default.Container.proxyConverter,\n        '$data.Date': _core2.default.Container.proxyConverter,\n        '$data.DateTimeOffset': _core2.default.Container.proxyConverter,\n        '$data.Time': _core2.default.Container.proxyConverter,\n        '$data.String': _core2.default.Container.proxyConverter,\n        '$data.Boolean': _core2.default.Container.proxyConverter,\n        '$data.Blob': function $dataBlob(b) {\n            return b ? _core2.default.Blob.toString(b) : b;\n        },\n        '$data.Array': function $dataArray(arr) {\n            return arr ? JSON.parse(JSON.stringify(arr)) : arr;\n        },\n        '$data.Object': _core2.default.Container.proxyConverter,\n        \"$data.Guid\": function $dataGuid(g) {\n            return g ? g.toString() : g;\n        },\n        '$data.GeographyPoint': function $dataGeographyPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyLineString': function $dataGeographyLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyPolygon': function $dataGeographyPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiPoint': function $dataGeographyMultiPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiLineString': function $dataGeographyMultiLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiPolygon': function $dataGeographyMultiPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyCollection': function $dataGeographyCollection(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryPoint': function $dataGeometryPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryLineString': function $dataGeometryLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryPolygon': function $dataGeometryPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiPoint': function $dataGeometryMultiPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiLineString': function $dataGeometryMultiLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiPolygon': function $dataGeometryMultiPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryCollection': function $dataGeometryCollection(g) {\n            if (g) {\n                return g;\n            }return g;\n        }\n    }\n};\n\n},{\"jaydata/core\":\"jaydata/core\"}],2:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.Class.define('$data.storageProviders.indexedDb.IndexedDBStorageProvider', _core2.default.StorageProviderBase, null, {\n    constructor: function constructor(cfg, ctxInstance) {\n        // mapping IndexedDB types to browser invariant name\n        this.indexedDB = _core2.default.__global.indexedDB || _core2.default.__global.webkitIndexedDB || _core2.default.__global.mozIndexedDB || _core2.default.__global.msIndexedDB;\n        this.IDBRequest = _core2.default.__global.IDBRequest || _core2.default.__global.webkitIDBRequest || _core2.default.__global.mozIDBRequest || _core2.default.__global.msIDBRequest;\n        this.IDBTransaction = _core2.default.__global.IDBTransaction || _core2.default.__global.webkitIDBTransaction || _core2.default.__global.mozIDBTransaction || _core2.default.__global.msIDBTransaction;\n        this.IDBTransactionType = { READ_ONLY: \"readonly\", READ_WRITE: \"readwrite\", VERSIONCHANGE: \"versionchange\" };\n        if (typeof this.IDBTransaction.READ_ONLY !== 'undefined' && typeof this.IDBTransaction.READ_WRITE !== 'undefined') {\n            this.IDBTransactionType.READ_ONLY = this.IDBTransaction.READ_ONLY;\n            this.IDBTransactionType.READ_WRITE = this.IDBTransaction.READ_WRITE;\n        }\n\n        this.IDBKeyRange = _core2.default.__global.IDBKeyRange || _core2.default.__global.webkitIDBKeyRange || _core2.default.__global.mozIDBKeyRange || _core2.default.__global.msIDBKeyRange;\n        this.IDBDatabaseException = _core2.default.__global.IDBDatabaseException || _core2.default.__global.webkitIDBDatabaseException || _core2.default.__global.mozIDBDatabaseException || _core2.default.__global.msIDBDatabaseException;\n        this.IDBOpenDBRequest = _core2.default.__global.IDBOpenDBRequest || _core2.default.__global.webkitIDBOpenDBRequest || _core2.default.__global.mozIDBOpenDBRequest || _core2.default.__global.msIDBOpenDBRequest;\n        this.newVersionAPI = !!(_core2.default.__global.IDBFactory && IDBFactory.prototype.deleteDatabase);\n        this.sequenceStore = '__jayData_sequence';\n        this.SqlCommands = [];\n        this.context = {};\n        this.providerConfiguration = _core2.default.typeSystem.extend({\n            databaseName: _core2.default.defaults.defaultDatabaseName,\n            version: 1,\n            dbCreation: _core2.default.storageProviders.DbCreationType.DropTableIfChanged,\n            memoryOperations: true\n        }, cfg);\n        this._setupExtensionMethods();\n\n        if (ctxInstance) this.originalContext = ctxInstance.getType();\n    },\n    supportedBinaryOperators: {\n        value: {\n            equal: { mapTo: ' == ', dataType: _core2.default.Boolean },\n            notEqual: { mapTo: ' != ', dataType: _core2.default.Boolean },\n            equalTyped: { mapTo: ' == ', dataType: _core2.default.Boolean },\n            notEqualTyped: { mapTo: ' != ', dataType: _core2.default.Boolean },\n            greaterThan: { mapTo: ' > ', dataType: _core2.default.Boolean },\n            greaterThanOrEqual: { mapTo: ' >= ', dataType: _core2.default.Boolean },\n\n            lessThan: { mapTo: ' < ', dataType: _core2.default.Boolean },\n            lessThenOrEqual: { mapTo: ' <= ', dataType: _core2.default.Boolean },\n            or: { mapTo: ' || ', dataType: _core2.default.Boolean },\n            and: { mapTo: ' && ', dataType: _core2.default.Boolean }\n            //'in': { mapTo: ' in ', dataType: $data.Boolean, resolvableType: [$data.Array, $data.Queryable] }\n        }\n    },\n    supportedSetOperations: {\n        value: {\n            length: {},\n            toArray: {},\n            forEach: {}\n        },\n        enumerable: true,\n        writable: true\n    },\n    supportedFieldOperations: {\n        value: {},\n        enumerable: true,\n        writable: true\n    },\n    supportedUnaryOperators: {\n        value: {},\n        enumerable: true,\n        writable: true\n    },\n    _setupExtensionMethods: function _setupExtensionMethods() {\n        /// <summary>\n        /// Sets the extension method 'setCallback' on IDBRequest, IDBOpenDBRequest, and IDBTransaction types\n        /// </summary>\n        var self = this;\n        var idbRequest = this.IDBRequest;\n        var idbTran = this.IDBTransaction;\n        var idbOpenDBRequest = this.IDBOpenDBRequest;\n        var setCallbacks = function setCallbacks(callbackSettings) {\n            /// <summary>\n            /// Sets the callbacks on the object.\n            /// </summary>\n            /// <param name=\"callbackSettings\">Named value pairs of the callbacks</param>\n            if ((typeof callbackSettings === 'undefined' ? 'undefined' : _typeof(callbackSettings)) !== 'object') _core.Guard.raise(new _core.Exception('Invalid callbackSettings', null, callbackSettings));\n            for (var i in callbackSettings) {\n                if (typeof this[i] === 'undefined' || typeof callbackSettings[i] !== 'function') continue;\n                this[i] = callbackSettings[i];\n            }\n\n            //if (this.readyState == self.IDBRequest.DONE)\n            //    console.log('WARNING: request finished before setCallbacks. Do not use breakpoints between creating the request object and finishing the setting of callbacks');\n            return this;\n        };\n        if (idbRequest && typeof idbRequest.prototype.setCallbacks !== 'function') idbRequest.prototype.setCallbacks = setCallbacks;\n        if (idbTran && typeof idbTran.prototype.setCallbacks !== 'function') idbTran.prototype.setCallbacks = setCallbacks;\n        if (idbOpenDBRequest && typeof idbOpenDBRequest.prototype.setCallbacks !== 'function') idbOpenDBRequest.prototype.setCallbacks = setCallbacks;\n    },\n    supportedDataTypes: {\n        value: [_core2.default.Integer, _core2.default.Number, _core2.default.Date, _core2.default.String, _core2.default.Boolean, _core2.default.Blob, _core2.default.Array, _core2.default.Object, _core2.default.Guid, _core2.default.GeographyPoint, _core2.default.GeographyLineString, _core2.default.GeographyPolygon, _core2.default.GeographyMultiPoint, _core2.default.GeographyMultiLineString, _core2.default.GeographyMultiPolygon, _core2.default.GeographyCollection, _core2.default.GeometryPoint, _core2.default.GeometryLineString, _core2.default.GeometryPolygon, _core2.default.GeometryMultiPoint, _core2.default.GeometryMultiLineString, _core2.default.GeometryMultiPolygon, _core2.default.GeometryCollection, _core2.default.Byte, _core2.default.SByte, _core2.default.Decimal, _core2.default.Float, _core2.default.Int16, _core2.default.Int32, _core2.default.Int64, _core2.default.Time, _core2.default.DateTimeOffset],\n        writable: false\n    },\n    fieldConverter: { value: _core2.default.IndexedDBConverter },\n\n    supportedAutoincrementKeys: {\n        value: {\n            '$data.Integer': true,\n            '$data.Int32': true,\n            '$data.Guid': function $dataGuid() {\n                return _core2.default.createGuid();\n            }\n        }\n    },\n\n    _getObjectStoreDefinition: function _getObjectStoreDefinition(setDefinition) {\n        var contextStore = {\n            storeName: setDefinition.TableName\n        };\n        var keyFields = setDefinition.PhysicalType.memberDefinitions.getKeyProperties();\n\n        if (0 == keyFields.length) {\n            var error = new Error(\"Entity must have a key field: \" + contextStore.storeName);\n            error.name = \"KeyNotFoundError\";\n            throw error;\n        }\n        /*if (1 != keyFields.length) {\r\n            var error = new Error(\"Entity must have only one key field: \" + contextStore.storeName);\r\n            error.name = \"MultipleKeysNotSupportedError\";\r\n            throw error;\r\n        }*/\n        //var keyField = keyFields[0];\n        /*for (var i = 0; i < keyFields.length; i++) {\r\n              if (keyFields[i].computed === true &&\r\n                (\"$data.Integer\" !== Container.resolveName(keyFields[i].type))) {\r\n                var error = new Error(\"Computed key field must be of integer type: \" + contextStore.storeName);\r\n                error.name = \"ComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n            if (keyFields.length > 2 && keyFields[i].computed) {\r\n                var error = new Error(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName);\r\n                error.name = \"MultipleComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n        }*/\n\n        if (keyFields.length > 2 && keyFields.some(function (memDef) {\n            return memDef.computed;\n        })) {\n            _core.Guard.raise(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName, \"MultipleComputedKeyFieldError\");\n        }\n\n        for (var i = 0; i < keyFields.length; i++) {\n            var typeName = _core.Container.resolveName(keyFields[i].type);\n            if (keyFields[i].computed && !this.supportedAutoincrementKeys[typeName]) {\n                console.log(\"WARRNING! '\" + typeName + \"' not supported as computed Key!\");\n            }\n        }\n\n        contextStore.keyFields = keyFields;\n        return contextStore;\n    },\n\n    _getObjectStoreDefinitions: function _getObjectStoreDefinitions() {\n        var objectStoreDefinitions = [];\n        var self = this;\n        self.context._storageModel.forEach(function (memDef) {\n            var objectStoreDefinition = self._getObjectStoreDefinition(memDef);\n            objectStoreDefinitions.push(objectStoreDefinition);\n        });\n        return objectStoreDefinitions;\n    },\n\n    _oldCreateDB: function _oldCreateDB(setVersionTran, definitions, onready) {\n        var self = this;\n        setVersionTran.db.onversionchange = function (event) {\n            return event.target.close();\n        };\n\n        self._createDB(setVersionTran.db, definitions);\n        setVersionTran.oncomplete = onready;\n    },\n    _createDB: function _createDB(db, definitions) {\n        for (var i = 0; i < definitions.length; i++) {\n            if (definitions[i].dropIfExists && db.objectStoreNames.contains(definitions[i].storeName)) {\n                db.deleteObjectStore(definitions[i].storeName);\n            }\n        }\n\n        for (var i = 0; i < definitions.length; i++) {\n            var storeDef = definitions[i];\n\n            if (!db.objectStoreNames.contains(storeDef.storeName)) {\n                var settings = {};\n                if (storeDef.keyFields.length == 1) {\n                    settings = {\n                        keyPath: storeDef.keyFields[0].name\n                        //autoIncrement: storeDef.keyFields[0].computed\n                    };\n                    var typeName = _core.Container.resolveName(storeDef.keyFields[0].type);\n                    settings.autoIncrement = this.supportedAutoincrementKeys[typeName] ? true : false;\n                } else {\n                    settings.key = [];\n                    for (var i = 0; i < storeDef.keyFields.length; i++) {\n                        settings.key.push(storeDef.keyFields[i].name);\n                    }\n                }\n                db.createObjectStore(storeDef.storeName, settings);\n            }\n        }\n    },\n    _hasDbChanges: function _hasDbChanges(db, definitions, dropTabes) {\n        var isOriginal = true;\n        for (var i = 0; i < definitions.length; i++) {\n            isOriginal = isOriginal && db.objectStoreNames.contains(definitions[i].storeName);\n\n            if (dropTabes) {\n                definitions[i].dropIfExists = true;\n                isOriginal = false;\n            }\n        }\n\n        return !isOriginal;\n    },\n    onupgradeneeded: function onupgradeneeded(objectStoreDefinitions) {\n        var self = this;\n        return function (e) {\n            var db = e.target.result;\n            db.onversionchange = function (event) {\n                return event.target.close();\n            };\n            var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == _core2.default.storageProviders.DbCreationType.DropAllExistingTables);\n            if (hasTableChanges) self._createDB(db, objectStoreDefinitions);\n        };\n    },\n\n    initializeStore: function initializeStore(callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        this.initializeMemoryStore({\n            success: function success() {\n                var objectStoreDefinitions;\n                try {\n                    objectStoreDefinitions = self._getObjectStoreDefinitions();\n                } catch (e) {\n                    console.log(objectStoreDefinitions);\n                    callBack.error(e);\n                    return;\n                }\n                self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks({\n                    onsuccess: function onsuccess(e) {\n                        var db = e.target.result;\n                        db.onversionchange = function (event) {\n                            return event.target.close();\n                        };\n\n                        var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == _core2.default.storageProviders.DbCreationType.DropAllExistingTables);\n                        //oldAPI\n                        if (db.setVersion) {\n                            if (db.version === \"\" || hasTableChanges) {\n                                db.setVersion((parseInt(db.version) || 0) + 1).setCallbacks({\n                                    onsuccess: function onsuccess(e) {\n                                        var db = e.target.result;\n                                        self._oldCreateDB(db /*setVerTran*/, objectStoreDefinitions, function (e) {\n                                            self.db = e.target.db;\n                                            callBack.success(self.context);\n                                        });\n                                    },\n                                    onerror: function onerror() {\n                                        var v = arguments;\n                                    },\n                                    onblocked: function onblocked() {\n                                        var v = arguments;\n                                    }\n                                });\n                                return;\n                            };\n                        } else if (hasTableChanges) {\n                            //newVersionAPI\n                            db.close();\n                            var version = parseInt(db.version) + 1;\n                            self.indexedDB.open(self.providerConfiguration.databaseName, version).setCallbacks({\n                                onsuccess: function onsuccess(e) {\n                                    self.db = e.target.result;\n                                    callBack.success(self.context);\n                                },\n                                onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\n                                onerror: callBack.error,\n                                onabort: callBack.error,\n                                onblocked: callBack.error\n                            });\n                            return;\n                        }\n\n                        self.db = db;\n                        callBack.success(self.context);\n                    },\n                    //newVersionAPI\n                    onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\n                    onerror: callBack.error,\n                    onabort: callBack.error,\n                    onblocked: callBack.error\n                });\n            },\n            error: callBack.error\n        });\n    },\n    initializeMemoryStore: function initializeMemoryStore(callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        if (self.originalContext && self.providerConfiguration.memoryOperations) {\n            self.operationProvider = new self.originalContext({ name: 'InMemory' });\n            self.operationProvider.onReady({\n                success: function success() {\n                    self.supportedBinaryOperators = self.operationProvider.storageProvider.supportedBinaryOperators;\n                    self.supportedSetOperations = self.operationProvider.storageProvider.supportedSetOperations;\n                    self.supportedFieldOperations = self.operationProvider.storageProvider.supportedFieldOperations;\n                    self.supportedUnaryOperators = self.operationProvider.storageProvider.supportedUnaryOperators;\n                    callBack.success();\n                },\n                error: callBack.error\n            });\n        } else {\n            callBack.success();\n        }\n    },\n\n    _initializeStore: function _initializeStore(callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        var initDb = function initDb(db) {\n            db.onversionchange = function (event) {\n                var ret = event.target.close();\n                return ret;\n            };\n            var newSequences = [];\n            self.context._storageModel.forEach(function (memDef) {\n                function createStore() {\n                    /// <summary>\n                    /// Creates a store for 'memDef'\n                    /// </summary>\n                    var osParam = {};\n                    var keySettings = self._getKeySettings(memDef);\n                    if (self.newVersionAPI) {\n                        if (keySettings.autoIncrement) newSequences.push(memDef.TableName);\n                    } else {\n                        osParam.autoIncrement = keySettings.autoIncrement;\n                    }\n                    if (keySettings.keyPath !== undefined) osParam.keyPath = keySettings.keyPath;\n                    db.createObjectStore(memDef.TableName, osParam);\n                }\n                if (db.objectStoreNames.contains(memDef.TableName)) {\n                    // ObjectStore already present.\n                    if (self.providerConfiguration.dbCreation === _core2.default.storageProviders.DbCreationType.DropAllExistingTables) {\n                        // Force drop and recreate object store\n                        db.deleteObjectStore(memDef.TableName);\n                        createStore();\n                    }\n                } else {\n                    // Store does not exists yet, we need to create it\n                    createStore();\n                }\n            });\n            if (newSequences.length > 0 && !db.objectStoreNames.contains(self.sequenceStore)) {\n                // Sequence store does not exists yet, we create it\n                db.createObjectStore(self.sequenceStore, { keyPath: 'store' });\n                newSequences = [];\n            }\n            return newSequences;\n        };\n        var newSequences = null;\n        // Creating openCallbacks settings for both type of db.open() method\n        var openCallbacks = {\n            onupgradeneeded: function onupgradeneeded(event) {\n                newSequences = initDb(event.target.result);\n            },\n            onerror: callBack.error,\n            onblocked: callBack.error,\n            onsuccess: function onsuccess(event) {\n                self.db = event.target.result;\n                self.db.onversionchange = function (event) {\n                    event.target.close();\n                };\n                if (self.newVersionAPI) {\n                    if (newSequences && newSequences.length > 0) {\n                        var store = self.db.transaction([self.sequenceStore], self.IDBTransactionType.READ_WRITE).setCallbacks({\n                            onerror: callBack.error,\n                            oncomplete: function oncomplete() {\n                                callBack.success(self.context);\n                            }\n                        }).objectStore(self.sequenceStore);\n                        switch (self.providerConfiguration.dbCreation) {\n                            case _core2.default.storageProviders.DbCreationType.DropAllExistingTables:\n                            case _core2.default.storageProviders.DbCreationType.DropTableIfChanged:\n                                // Clearing all data\n                                store.clear();\n                                break;\n                            default:\n                                // Removing data for newly created stores, if they previously existed\n                                newSequences.forEach(function (item) {\n                                    store['delete'](item);\n                                });\n                                break;\n                        }\n                    }\n                    callBack.success(self.context);\n                } else {\n                    // Calling setVersion on webkit\n                    var versionRequest = self.db.setVersion(self.providerConfiguration.version.toString()).setCallbacks({\n                        onerror: callBack.error,\n                        onblocked: callBack.error,\n                        onsuccess: function onsuccess(event) {\n                            initDb(self.db);\n                            versionRequest.result.oncomplete = function (evt) {\n                                callBack.success(self.context);\n                            };\n                        }\n                    });\n                }\n            }\n        };\n        // For Firefox we need to pass the version here\n        if (self.newVersionAPI) self.indexedDB.open(self.providerConfiguration.databaseName, parseInt(self.providerConfiguration.version, 10)).setCallbacks(openCallbacks);else self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks(openCallbacks);\n    },\n\n    executeQuery: function executeQuery(query, callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        //var compiledQuery = self._compile(query);\n\n        // Creating read only transaction for query. Results are passed in transaction's oncomplete event\n        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);\n        var store = self.db.transaction([entitySet.tableName], self.IDBTransactionType.READ_ONLY).setCallbacks({\n            onerror: callBack.error,\n            onabort: callBack.error,\n            oncomplete: function oncomplete(event) {\n                if (self.operationProvider) {\n                    self.operationProvider.storageProvider.dataSource[entitySet.tableName] = query.rawDataList;\n                    self.operationProvider.storageProvider.executeQuery(query, {\n                        success: function success(query) {\n                            if (query.expression.nodeType === _core2.default.Expressions.ExpressionType.Count) {\n                                query.rawDataList[0] = { cnt: query.rawDataList[0] };\n                            }\n                            callBack.success(query);\n                        },\n                        error: callBack.error\n                    });\n                } else {\n                    callBack.success(query);\n                }\n            }\n        }).objectStore(entitySet.tableName);\n        var modelBinderCompiler = _core.Container.createModelBinderConfigCompiler(query, []);\n        modelBinderCompiler.Visit(query.expression);\n\n        if (self.operationProvider) {\n            store.openCursor().onsuccess = function (event) {\n                // We currently support only toArray() so let's just dump all data\n                var cursor = event.target.result;\n                if (cursor) {\n                    var value = cursor.value;\n                    query.rawDataList.push(cursor.value);\n                    cursor['continue']();\n                }\n            };\n        } else {\n            switch (query.expression.nodeType) {\n                case _core2.default.Expressions.ExpressionType.Count:\n                    store.count().onsuccess = function (event) {\n                        var count = event.target.result;\n                        query.rawDataList.push({ cnt: count });\n                    };\n                    break;\n                default:\n                    store.openCursor().onsuccess = function (event) {\n                        // We currently support only toArray() so let's just dump all data\n                        var cursor = event.target.result;\n                        if (cursor) {\n                            var value = cursor.value;\n                            query.rawDataList.push(cursor.value);\n                            cursor['continue']();\n                        }\n                    };\n                    break;\n            }\n        };\n    },\n    _getKeySettings: function _getKeySettings(memDef) {\n        /// <summary>\n        /// Gets key settings for item type's member definition\n        /// </summary>\n        /// <param name=\"memDef\">memDef of item</param>\n        /// <returns>KeySettings object</returns>\n        var self = this;\n        var settings = { autoIncrement: false };\n        var keys = [];\n        memDef.PhysicalType.memberDefinitions.getPublicMappedProperties().forEach(function (item) {\n            if (item.key) {\n                // We found a key\n                keys.push(item.name);\n            }\n            if (item.computed) {\n                // AutoIncrement field, must be key\n                if (!item.key) _core.Guard.raise(new _core.Exception('Only key field can be a computed field!'));\n\n                var typeName = _core.Container.resolveName(item.type);\n                if (self.supportedAutoincrementKeys[typeName] === true) {\n                    settings.autoIncrement = true;\n                }\n            }\n        });\n        if (keys.length > 1) {\n            if (settings.autoIncrement) _core.Guard.raise(new _core.Exception('Auto increment is only valid for a single key!'));\n            // Setting key fields (composite key)\n            settings.keys = keys;\n        } else if (keys.length == 1) {\n            // Simple key\n            settings.keyPath = keys[0];\n        } else {\n            _core.Guard.raise(new _core.Exception('No valid key found!'));\n        }\n        return settings;\n    },\n    saveChanges: function saveChanges(callBack, changedItems) {\n        var self = this;\n        // Building independent blocks and processing them sequentially\n        var independentBlocks = self.buildIndependentBlocks(changedItems);\n        function saveNextIndependentBlock() {\n            /// <summary>\n            /// Saves the next independent block\n            /// </summary>\n            if (independentBlocks.length === 0) {\n                // No more blocks left, calling success callback\n                callBack.success();\n            } else {\n                var KeySettingsCache = function KeySettingsCache() {\n                    /// <summary>\n                    /// Simple cache for key settings of types\n                    /// </summary>\n                    var cache = {};\n                    this.getSettingsForItem = function (item) {\n                        var typeName = item.data.getType().fullName;\n                        if (!cache.hasOwnProperty(typeName)) {\n                            cache[typeName] = self._getKeySettings(self.context._storageModel.getStorageModel(item.data.getType()));\n                        }\n                        return cache[typeName];\n                    };\n                };\n\n                // 'Popping' next block\n                var currentBlock = independentBlocks.shift();\n                // Collecting stores of items for transaction initialize\n                var storesObj = {};\n                // Generating physicalData\n                var convertedItems = currentBlock.map(function (item) {\n                    storesObj[item.entitySet.tableName] = true;\n                    item.physicalData = {};\n                    item.entitySet.elementType.memberDefinitions.getPublicMappedProperties().forEach(function (memDef) {\n                        var typeName = _core.Container.resolveName(memDef.type);\n                        if (memDef.key && memDef.computed && item.data[memDef.name] == undefined) {\n                            if (typeof self.supportedAutoincrementKeys[typeName] === 'function') {\n                                var keyValue = self.supportedAutoincrementKeys[typeName]();\n                                item.data[memDef.name] = self.fieldConverter.toDb[typeName](keyValue);\n                            } else {\n                                // Autogenerated fields for new items should not be present in the physicalData\n                                return;\n                            }\n                        }\n                        if (!memDef.inverseProperty && typeof memDef.concurrencyMode === 'undefined' && (memDef.key === true || item.data.entityState === _core2.default.EntityState.Added || item.data.changedProperties && item.data.changedProperties.some(function (def) {\n                            return def.name === memDef.name;\n                        }))) {\n                            if (self.fieldConverter.toDb[typeName]) {\n                                item.physicalData[memDef.name] = self.fieldConverter.toDb[typeName](item.data[memDef.name]);\n                            } else {\n                                var value = item.data[memDef.name];\n                                if (value !== undefined) {\n                                    value = JSON.parse(JSON.stringify(value));\n                                }\n                                item.physicalData[memDef.name] = value;\n                            }\n                        }\n                    });\n                    return item;\n                });\n                var stores = [];\n                for (var i in storesObj) {\n                    stores.push(i);\n                }\n                var tran = self.db.transaction(stores, self.IDBTransactionType.READ_WRITE).setCallbacks({\n                    onerror: function onerror(event) {\n                        // Only call the error callback when it's not because of an abort\n                        // aborted cases should call the error callback there\n                        if (!event.target || !self.IDBDatabaseException || event.target && self.IDBDatabaseException && event.target.errorCode !== self.IDBDatabaseException.ABORT_ERR) callBack.error(event);\n                    },\n                    oncomplete: function oncomplete(event) {\n                        // Moving to next block\n                        saveNextIndependentBlock();\n                    }\n                });\n\n                var ksCache = new KeySettingsCache();\n                convertedItems.forEach(function (item) {\n                    // Getting store and keysettings for the current item\n                    var store = tran.objectStore(item.entitySet.tableName);\n                    var keySettings = ksCache.getSettingsForItem(item);\n                    // Contains the keys that should be passed for create, update and delete (composite keys)\n                    var itemKeys = keySettings.keys && keySettings.keys.map(function (key) {\n                        return item.physicalData[key];\n                    }) || null;\n                    try {\n                        var cursorAction = function cursorAction(action) {\n                            /// <summary>\n                            /// Find the current item in the store, and calls the action on it. Error raised when item was not found\n                            /// </summary>\n                            /// <param name=\"action\">Action to call on the item</param>\n                            var key = keySettings.keyPath ? item.physicalData[keySettings.keyPath] : itemKeys;\n                            var data = item.physicalData;\n                            store.openCursor(self.IDBKeyRange.only(key)).onsuccess = function (event) {\n                                try {\n                                    var cursor = event.target.result;\n                                    if (cursor) action(cursor, key, data);else _core.Guard.raise(new _core.Exception('Object not found', null, item));\n                                } catch (ex) {\n                                    tran.abort();\n                                    callBack.error(ex);\n                                }\n                            };\n                        };\n                        switch (item.data.entityState) {\n                            case _core2.default.EntityState.Added:\n                                if (!keySettings.keyPath) {\n                                    // Item needs explicit keys\n                                    store.add(item.physicalData, itemKeys);\n                                } else {\n                                    store.add(item.physicalData).onsuccess = function (event) {\n                                        // Saves the generated key back to the entity\n                                        item.data[keySettings.keyPath] = event.target.result;\n                                    };\n                                }\n                                break;\n                            case _core2.default.EntityState.Deleted:\n                                // Deletes the item\n                                cursorAction(function (cursor) {\n                                    cursor['delete']();\n                                });\n                                break;\n                            case _core2.default.EntityState.Modified:\n                                // Updates the item\n                                cursorAction(function (cursor, key, data) {\n                                    cursor.update(_core2.default.typeSystem.extend(cursor.value, data));\n                                });\n                                break;\n                            case _core2.default.EntityState.Unchanged:\n                                break;\n                            default:\n                                _core.Guard.raise(new _core.Exception('Not supported entity state', null, item));\n                        }\n                    } catch (ex) {\n                        // Abort on exceptions\n                        tran.abort();\n                        callBack.error(ex);\n                    }\n                });\n            }\n        }\n        saveNextIndependentBlock();\n    },\n    _compile: function _compile(query) {\n        var sqlText = _core.Container.createIndexedDBCompiler().compile(query);\n        return sqlText;\n    }\n}, {\n    isSupported: {\n        get: function get() {\n            return _core2.default.__global.indexedDB || _core2.default.__global.webkitIndexedDB || _core2.default.__global.mozIndexedDB || _core2.default.__global.msIndexedDB ? true : false;\n        },\n        set: function set() {}\n    }\n});\n\nif (_core2.default.storageProviders.indexedDb.IndexedDBStorageProvider.isSupported) _core2.default.StorageProviderBase.registerProvider('indexedDb', _core2.default.storageProviders.indexedDb.IndexedDBStorageProvider);\n\n},{\"jaydata/core\":\"jaydata/core\"}],3:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _IndexedDBConverter = _dereq_('./IndexedDBConverter.js');\n\nvar _IndexedDBConverter2 = _interopRequireDefault(_IndexedDBConverter);\n\nvar _IndexedDBStorageProvider = _dereq_('./IndexedDBStorageProvider.js');\n\nvar _IndexedDBStorageProvider2 = _interopRequireDefault(_IndexedDBStorageProvider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _core2.default;\nmodule.exports = exports['default'];\n\n},{\"./IndexedDBConverter.js\":1,\"./IndexedDBStorageProvider.js\":2,\"jaydata/core\":\"jaydata/core\"}]},{},[3])(3)\n});\n\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\n\r\n$data.IndexedDBConverter = {\r\n    fromDb: {\r\n        '$data.Byte': $data.Container.proxyConverter,\r\n        '$data.SByte': $data.Container.proxyConverter,\r\n        '$data.Decimal': $data.Container.proxyConverter,\r\n        '$data.Float': $data.Container.proxyConverter,\r\n        '$data.Int16': $data.Container.proxyConverter,\r\n        '$data.Int64': $data.Container.proxyConverter,\r\n        '$data.Integer': $data.Container.proxyConverter,\r\n        '$data.Int32': $data.Container.proxyConverter,\r\n        '$data.Number': $data.Container.proxyConverter,\r\n        '$data.Date': $data.Container.proxyConverter,\r\n        '$data.DateTimeOffset': $data.Container.proxyConverter,\r\n        '$data.Time': $data.Container.proxyConverter,\r\n        '$data.String': $data.Container.proxyConverter,\r\n        '$data.Boolean': $data.Container.proxyConverter,\r\n        '$data.Blob': function (b) { return b ? $data.Container.convertTo(b, $data.Blob) : b; },\r\n        '$data.Array': function (arr) { if (arr === undefined) { return new $data.Array(); } return arr; },\r\n        '$data.Object': $data.Container.proxyConverter,\r\n        \"$data.Guid\": function (g) { return g ? $data.parseGuid(g).toString() : g; },\r\n        '$data.GeographyPoint': function (g) { if (g) { return new $data.GeographyPoint(g); } return g; },\r\n        '$data.GeographyLineString': function (g) { if (g) { return new $data.GeographyLineString(g); } return g; },\r\n        '$data.GeographyPolygon': function (g) { if (g) { return new $data.GeographyPolygon(g); } return g; },\r\n        '$data.GeographyMultiPoint': function (g) { if (g) { return new $data.GeographyMultiPoint(g); } return g; },\r\n        '$data.GeographyMultiLineString': function (g) { if (g) { return new $data.GeographyMultiLineString(g); } return g; },\r\n        '$data.GeographyMultiPolygon': function (g) { if (g) { return new $data.GeographyMultiPolygon(g); } return g; },\r\n        '$data.GeographyCollection': function (g) { if (g) { return new $data.GeographyCollection(g); } return g; },\r\n        '$data.GeometryPoint': function (g) { if (g) { return new $data.GeometryPoint(g); } return g; },\r\n        '$data.GeometryLineString': function (g) { if (g) { return new $data.GeometryLineString(g); } return g; },\r\n        '$data.GeometryPolygon': function (g) { if (g) { return new $data.GeometryPolygon(g); } return g; },\r\n        '$data.GeometryMultiPoint': function (g) { if (g) { return new $data.GeometryMultiPoint(g); } return g; },\r\n        '$data.GeometryMultiLineString': function (g) { if (g) { return new $data.GeometryMultiLineString(g); } return g; },\r\n        '$data.GeometryMultiPolygon': function (g) { if (g) { return new $data.GeometryMultiPolygon(g); } return g; },\r\n        '$data.GeometryCollection': function (g) { if (g) { return new $data.GeometryCollection(g); } return g; }\r\n    },\r\n    toDb: {\r\n        '$data.Byte': $data.Container.proxyConverter,\r\n        '$data.SByte': $data.Container.proxyConverter,\r\n        '$data.Decimal': $data.Container.proxyConverter,\r\n        '$data.Float': $data.Container.proxyConverter,\r\n        '$data.Int16': $data.Container.proxyConverter,\r\n        '$data.Int64': $data.Container.proxyConverter,\r\n        '$data.Integer': $data.Container.proxyConverter,\r\n        '$data.Int32': $data.Container.proxyConverter,\r\n        '$data.Number': $data.Container.proxyConverter,\r\n        '$data.Date': $data.Container.proxyConverter,\r\n        '$data.DateTimeOffset': $data.Container.proxyConverter,\r\n        '$data.Time': $data.Container.proxyConverter,\r\n        '$data.String': $data.Container.proxyConverter,\r\n        '$data.Boolean': $data.Container.proxyConverter,\r\n        '$data.Blob': function(b){ return b ? $data.Blob.toString(b) : b; },\r\n        '$data.Array': function (arr) { return arr ? JSON.parse(JSON.stringify(arr)) : arr; },\r\n        '$data.Object': $data.Container.proxyConverter,\r\n        \"$data.Guid\": function (g) { return g ? g.toString() : g; },\r\n        '$data.GeographyPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyCollection': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryCollection': function (g) { if (g) { return g; } return g; }\r\n    }\r\n};\r\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\n\r\n$data.Class.define('$data.storageProviders.indexedDb.IndexedDBStorageProvider', $data.StorageProviderBase, null,\r\n{\r\n    constructor: function (cfg, ctxInstance) {\r\n        // mapping IndexedDB types to browser invariant name\r\n        this.indexedDB = $data.__global.indexedDB || $data.__global.webkitIndexedDB || $data.__global.mozIndexedDB || $data.__global.msIndexedDB;\r\n        this.IDBRequest = $data.__global.IDBRequest || $data.__global.webkitIDBRequest || $data.__global.mozIDBRequest || $data.__global.msIDBRequest;\r\n        this.IDBTransaction = $data.__global.IDBTransaction || $data.__global.webkitIDBTransaction || $data.__global.mozIDBTransaction || $data.__global.msIDBTransaction;\r\n        this.IDBTransactionType = { READ_ONLY: \"readonly\", READ_WRITE: \"readwrite\", VERSIONCHANGE: \"versionchange\" }\r\n        if (typeof this.IDBTransaction.READ_ONLY !== 'undefined' && typeof this.IDBTransaction.READ_WRITE !== 'undefined') {\r\n            this.IDBTransactionType.READ_ONLY = this.IDBTransaction.READ_ONLY\r\n            this.IDBTransactionType.READ_WRITE = this.IDBTransaction.READ_WRITE\r\n        }\r\n\r\n        this.IDBKeyRange = $data.__global.IDBKeyRange || $data.__global.webkitIDBKeyRange || $data.__global.mozIDBKeyRange || $data.__global.msIDBKeyRange;\r\n        this.IDBDatabaseException = $data.__global.IDBDatabaseException || $data.__global.webkitIDBDatabaseException || $data.__global.mozIDBDatabaseException || $data.__global.msIDBDatabaseException;\r\n        this.IDBOpenDBRequest = $data.__global.IDBOpenDBRequest || $data.__global.webkitIDBOpenDBRequest || $data.__global.mozIDBOpenDBRequest || $data.__global.msIDBOpenDBRequest;\r\n        this.newVersionAPI = !!($data.__global.IDBFactory && IDBFactory.prototype.deleteDatabase);\r\n        this.sequenceStore = '__jayData_sequence';\r\n        this.SqlCommands = [];\r\n        this.context = {};\r\n        this.providerConfiguration = $data.typeSystem.extend({\r\n            databaseName: $data.defaults.defaultDatabaseName,\r\n            version: 1,\r\n            dbCreation: $data.storageProviders.DbCreationType.DropTableIfChanged,\r\n            memoryOperations: true\r\n        }, cfg);\r\n        this._setupExtensionMethods();\r\n\r\n        if (ctxInstance)\r\n            this.originalContext = ctxInstance.getType();\r\n    },\r\n    supportedBinaryOperators: {\r\n        value: {\r\n            equal: { mapTo: ' == ', dataType: $data.Boolean },\r\n            notEqual: { mapTo: ' != ', dataType: $data.Boolean },\r\n            equalTyped: { mapTo: ' == ', dataType: $data.Boolean },\r\n            notEqualTyped: { mapTo: ' != ', dataType: $data.Boolean },\r\n            greaterThan: { mapTo: ' > ', dataType: $data.Boolean },\r\n            greaterThanOrEqual: { mapTo: ' >= ', dataType: $data.Boolean },\r\n\r\n            lessThan: { mapTo: ' < ', dataType: $data.Boolean },\r\n            lessThenOrEqual: { mapTo: ' <= ', dataType: $data.Boolean },\r\n            or: { mapTo: ' || ', dataType: $data.Boolean },\r\n            and: { mapTo: ' && ', dataType: $data.Boolean }\r\n            //'in': { mapTo: ' in ', dataType: $data.Boolean, resolvableType: [$data.Array, $data.Queryable] }\r\n        }\r\n    },\r\n    supportedSetOperations: {\r\n        value: {\r\n            length: {},\r\n            toArray: {},\r\n            forEach: {}\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    supportedFieldOperations: {\r\n        value: {\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    supportedUnaryOperators: {\r\n        value: {\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    _setupExtensionMethods: function () {\r\n        /// <summary>\r\n        /// Sets the extension method 'setCallback' on IDBRequest, IDBOpenDBRequest, and IDBTransaction types\r\n        /// </summary>\r\n        var self = this;\r\n        var idbRequest = this.IDBRequest;\r\n        var idbTran = this.IDBTransaction;\r\n        var idbOpenDBRequest = this.IDBOpenDBRequest;\r\n        var setCallbacks = function (callbackSettings) {\r\n            /// <summary>\r\n            /// Sets the callbacks on the object.\r\n            /// </summary>\r\n            /// <param name=\"callbackSettings\">Named value pairs of the callbacks</param>\r\n            if (typeof callbackSettings !== 'object')\r\n                Guard.raise(new Exception('Invalid callbackSettings', null, callbackSettings));\r\n            for (var i in callbackSettings) {\r\n                if (typeof this[i] === 'undefined' || typeof callbackSettings[i] !== 'function')\r\n                    continue;\r\n                this[i] = callbackSettings[i];\r\n            }\r\n\r\n            //if (this.readyState == self.IDBRequest.DONE)\r\n            //    console.log('WARNING: request finished before setCallbacks. Do not use breakpoints between creating the request object and finishing the setting of callbacks');\r\n            return this;\r\n        };\r\n        if (idbRequest && typeof idbRequest.prototype.setCallbacks !== 'function')\r\n            idbRequest.prototype.setCallbacks = setCallbacks;\r\n        if (idbTran && typeof idbTran.prototype.setCallbacks !== 'function')\r\n            idbTran.prototype.setCallbacks = setCallbacks;\r\n        if (idbOpenDBRequest && typeof idbOpenDBRequest.prototype.setCallbacks !== 'function')\r\n            idbOpenDBRequest.prototype.setCallbacks = setCallbacks;\r\n    },\r\n    supportedDataTypes: {\r\n        value: [$data.Integer, $data.Number, $data.Date, $data.String, $data.Boolean, $data.Blob, $data.Array, $data.Object, $data.Guid, $data.GeographyPoint,\r\n            $data.GeographyLineString, $data.GeographyPolygon, $data.GeographyMultiPoint, $data.GeographyMultiLineString, $data.GeographyMultiPolygon, $data.GeographyCollection,\r\n            $data.GeometryPoint, $data.GeometryLineString, $data.GeometryPolygon, $data.GeometryMultiPoint, $data.GeometryMultiLineString, $data.GeometryMultiPolygon, $data.GeometryCollection,\r\n            $data.Byte, $data.SByte, $data.Decimal, $data.Float, $data.Int16, $data.Int32, $data.Int64, $data.Time, $data.DateTimeOffset],\r\n        writable: false\r\n    },\r\n    fieldConverter: { value: $data.IndexedDBConverter },\r\n\r\n    supportedAutoincrementKeys: {\r\n        value: {\r\n            '$data.Integer': true,\r\n            '$data.Int32': true,\r\n            '$data.Guid': function () { return $data.createGuid(); }\r\n        }\r\n    },\r\n\r\n    _getObjectStoreDefinition: function (setDefinition) {\r\n        var contextStore = {\r\n            storeName: setDefinition.TableName\r\n        };\r\n        var keyFields = setDefinition.PhysicalType.memberDefinitions.getKeyProperties();\r\n\r\n        if (0 == keyFields.length) {\r\n            var error = new Error(\"Entity must have a key field: \" + contextStore.storeName);\r\n            error.name = \"KeyNotFoundError\";\r\n            throw error;\r\n        }\r\n        /*if (1 != keyFields.length) {\r\n            var error = new Error(\"Entity must have only one key field: \" + contextStore.storeName);\r\n            error.name = \"MultipleKeysNotSupportedError\";\r\n            throw error;\r\n        }*/\r\n        //var keyField = keyFields[0];\r\n        /*for (var i = 0; i < keyFields.length; i++) {\r\n\r\n            if (keyFields[i].computed === true &&\r\n                (\"$data.Integer\" !== Container.resolveName(keyFields[i].type))) {\r\n                var error = new Error(\"Computed key field must be of integer type: \" + contextStore.storeName);\r\n                error.name = \"ComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n            if (keyFields.length > 2 && keyFields[i].computed) {\r\n                var error = new Error(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName);\r\n                error.name = \"MultipleComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n        }*/\r\n\r\n        if (keyFields.length > 2 && keyFields.some(function (memDef) { return memDef.computed; })) {\r\n            Guard.raise(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName, \"MultipleComputedKeyFieldError\");\r\n        }\r\n\r\n        for (var i = 0; i < keyFields.length; i++) {\r\n            var typeName = Container.resolveName(keyFields[i].type);\r\n            if (keyFields[i].computed && !this.supportedAutoincrementKeys[typeName]) {\r\n                console.log(\"WARRNING! '\" + typeName + \"' not supported as computed Key!\");\r\n            }\r\n        }\r\n\r\n        contextStore.keyFields = keyFields;\r\n        return contextStore;\r\n    },\r\n\r\n    _getObjectStoreDefinitions: function () {\r\n        var objectStoreDefinitions = [];\r\n        var self = this;\r\n        self.context._storageModel.forEach(function (memDef) {\r\n            var objectStoreDefinition = self._getObjectStoreDefinition(memDef);\r\n            objectStoreDefinitions.push(objectStoreDefinition);\r\n        });\r\n        return objectStoreDefinitions;\r\n    },\r\n\r\n    _oldCreateDB: function (setVersionTran, definitions, onready) {\r\n        var self = this;\r\n        setVersionTran.db.onversionchange = function (event) {\r\n            return event.target.close();\r\n        };\r\n\r\n        self._createDB(setVersionTran.db, definitions);\r\n        setVersionTran.oncomplete = onready;\r\n    },\r\n    _createDB: function (db, definitions) {\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            if (definitions[i].dropIfExists && db.objectStoreNames.contains(definitions[i].storeName)) {\r\n                db.deleteObjectStore(definitions[i].storeName);\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            var storeDef = definitions[i];\r\n\r\n            if (!db.objectStoreNames.contains(storeDef.storeName)) {\r\n                var settings = {};\r\n                if (storeDef.keyFields.length == 1) {\r\n                    settings = {\r\n                        keyPath: storeDef.keyFields[0].name\r\n                        //autoIncrement: storeDef.keyFields[0].computed\r\n                    };\r\n                    var typeName = Container.resolveName(storeDef.keyFields[0].type);\r\n                    settings.autoIncrement = this.supportedAutoincrementKeys[typeName] ? true : false;\r\n                } else {\r\n                    settings.key = [];\r\n                    for (var i = 0; i < storeDef.keyFields.length; i++) {\r\n                        settings.key.push(storeDef.keyFields[i].name);\r\n                    }\r\n                }\r\n                db.createObjectStore(storeDef.storeName, settings);\r\n            }\r\n        }\r\n    },\r\n    _hasDbChanges: function (db, definitions, dropTabes) {\r\n        var isOriginal = true;\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            isOriginal = isOriginal && db.objectStoreNames.contains(definitions[i].storeName);\r\n\r\n            if (dropTabes) {\r\n                definitions[i].dropIfExists = true;\r\n                isOriginal = false;\r\n            }\r\n        }\r\n\r\n        return !isOriginal;\r\n    },\r\n    onupgradeneeded: function (objectStoreDefinitions) {\r\n        var self = this;\r\n        return function (e) {\r\n            var db = e.target.result;\r\n            db.onversionchange = function (event) {\r\n                return event.target.close();\r\n            };\r\n            var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == $data.storageProviders.DbCreationType.DropAllExistingTables);\r\n            if (hasTableChanges)\r\n                self._createDB(db, objectStoreDefinitions);\r\n        }\r\n    },\r\n\r\n    initializeStore: function (callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n        this.initializeMemoryStore({\r\n            success: function () {\r\n                var objectStoreDefinitions;\r\n                try {\r\n                    objectStoreDefinitions = self._getObjectStoreDefinitions();\r\n                } catch (e) {\r\n                    console.log(objectStoreDefinitions);\r\n                    callBack.error(e);\r\n                    return;\r\n                }\r\n                self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks({\r\n                    onsuccess: function (e) {\r\n                        var db = e.target.result;\r\n                        db.onversionchange = function (event) {\r\n                            return event.target.close();\r\n                        };\r\n\r\n                        var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == $data.storageProviders.DbCreationType.DropAllExistingTables);\r\n                        //oldAPI\r\n                        if (db.setVersion) {\r\n                            if (db.version === \"\" || hasTableChanges) {\r\n                                db.setVersion((parseInt(db.version) || 0) + 1).setCallbacks({\r\n                                    onsuccess: function (e) {\r\n                                        var db = e.target.result\r\n                                        self._oldCreateDB(db /*setVerTran*/, objectStoreDefinitions, function (e) {\r\n                                            self.db = e.target.db;\r\n                                            callBack.success(self.context);\r\n                                        });\r\n                                    },\r\n                                    onerror: function () {\r\n                                        var v = arguments;\r\n                                    },\r\n                                    onblocked: function () {\r\n                                        var v = arguments;\r\n                                    }\r\n                                });\r\n                                return;\r\n                            };\r\n                        } else if (hasTableChanges) {\r\n                            //newVersionAPI\r\n                            db.close();\r\n                            var version = parseInt(db.version) + 1;\r\n                            self.indexedDB.open(self.providerConfiguration.databaseName, version).setCallbacks({\r\n                                onsuccess: function (e) {\r\n                                    self.db = e.target.result;\r\n                                    callBack.success(self.context);\r\n                                },\r\n                                onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\r\n                                onerror: callBack.error,\r\n                                onabort: callBack.error,\r\n                                onblocked: callBack.error\r\n                            });\r\n                            return;\r\n                        }\r\n\r\n                        self.db = db;\r\n                        callBack.success(self.context);\r\n                    },\r\n                    //newVersionAPI\r\n                    onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\r\n                    onerror: callBack.error,\r\n                    onabort: callBack.error,\r\n                    onblocked: callBack.error\r\n                });\r\n            },\r\n            error: callBack.error\r\n        });\r\n    },\r\n    initializeMemoryStore: function (callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n        if (self.originalContext && self.providerConfiguration.memoryOperations) {\r\n            self.operationProvider = new self.originalContext({ name: 'InMemory' });\r\n            self.operationProvider.onReady({\r\n                success: function () {\r\n                    self.supportedBinaryOperators = self.operationProvider.storageProvider.supportedBinaryOperators;\r\n                    self.supportedSetOperations = self.operationProvider.storageProvider.supportedSetOperations;\r\n                    self.supportedFieldOperations = self.operationProvider.storageProvider.supportedFieldOperations;\r\n                    self.supportedUnaryOperators = self.operationProvider.storageProvider.supportedUnaryOperators;\r\n                    callBack.success();\r\n                },\r\n                error: callBack.error\r\n            });\r\n        } else {\r\n            callBack.success();\r\n        }\r\n    },\r\n\r\n    _initializeStore: function (callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n\r\n        var initDb = function (db) {\r\n            db.onversionchange = function (event) {\r\n                var ret = event.target.close();\r\n                return ret;\r\n            };\r\n            var newSequences = [];\r\n            self.context._storageModel.forEach(function (memDef) {\r\n                function createStore() {\r\n                    /// <summary>\r\n                    /// Creates a store for 'memDef'\r\n                    /// </summary>\r\n                    var osParam = {};\r\n                    var keySettings = self._getKeySettings(memDef);\r\n                    if (self.newVersionAPI) {\r\n                        if (keySettings.autoIncrement)\r\n                            newSequences.push(memDef.TableName);\r\n                    } else {\r\n                        osParam.autoIncrement = keySettings.autoIncrement;\r\n                    }\r\n                    if (keySettings.keyPath !== undefined)\r\n                        osParam.keyPath = keySettings.keyPath;\r\n                    db.createObjectStore(memDef.TableName, osParam);\r\n                }\r\n                if (db.objectStoreNames.contains(memDef.TableName)) {\r\n                    // ObjectStore already present.\r\n                    if (self.providerConfiguration.dbCreation === $data.storageProviders.DbCreationType.DropAllExistingTables) {\r\n                        // Force drop and recreate object store\r\n                        db.deleteObjectStore(memDef.TableName);\r\n                        createStore();\r\n                    }\r\n                } else {\r\n                    // Store does not exists yet, we need to create it\r\n                    createStore();\r\n                }\r\n            });\r\n            if (newSequences.length > 0 && !db.objectStoreNames.contains(self.sequenceStore)) {\r\n                // Sequence store does not exists yet, we create it\r\n                db.createObjectStore(self.sequenceStore, { keyPath: 'store' });\r\n                newSequences = [];\r\n            }\r\n            return newSequences;\r\n        }\r\n        var newSequences = null;\r\n        // Creating openCallbacks settings for both type of db.open() method\r\n        var openCallbacks = {\r\n            onupgradeneeded: function (event) {\r\n                newSequences = initDb(event.target.result);\r\n            },\r\n            onerror: callBack.error,\r\n            onblocked: callBack.error,\r\n            onsuccess: function (event) {\r\n                self.db = event.target.result;\r\n                self.db.onversionchange = function (event) {\r\n                    event.target.close();\r\n                }\r\n                if (self.newVersionAPI) {\r\n                    if (newSequences && newSequences.length > 0) {\r\n                        var store = self.db.transaction([self.sequenceStore], self.IDBTransactionType.READ_WRITE).setCallbacks({\r\n                            onerror: callBack.error,\r\n                            oncomplete: function () {\r\n                                callBack.success(self.context);\r\n                            }\r\n                        }).objectStore(self.sequenceStore);\r\n                        switch (self.providerConfiguration.dbCreation) {\r\n                            case $data.storageProviders.DbCreationType.DropAllExistingTables:\r\n                            case $data.storageProviders.DbCreationType.DropTableIfChanged:\r\n                                // Clearing all data\r\n                                store.clear();\r\n                                break;\r\n                            default:\r\n                                // Removing data for newly created stores, if they previously existed\r\n                                newSequences.forEach(function (item) {\r\n                                    store['delete'](item);\r\n                                });\r\n                                break;\r\n                        }\r\n                    }\r\n                    callBack.success(self.context);\r\n                }\r\n                else {\r\n                    // Calling setVersion on webkit\r\n                    var versionRequest = self.db.setVersion(self.providerConfiguration.version.toString()).setCallbacks({\r\n                        onerror: callBack.error,\r\n                        onblocked: callBack.error,\r\n                        onsuccess: function (event) {\r\n                            initDb(self.db);\r\n                            versionRequest.result.oncomplete = function (evt) {\r\n                                callBack.success(self.context);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        // For Firefox we need to pass the version here\r\n        if (self.newVersionAPI)\r\n            self.indexedDB.open(self.providerConfiguration.databaseName, parseInt(self.providerConfiguration.version, 10)).setCallbacks(openCallbacks);\r\n        else\r\n            self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks(openCallbacks);\r\n    },\r\n\r\n    executeQuery: function (query, callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n        //var compiledQuery = self._compile(query);\r\n\r\n        // Creating read only transaction for query. Results are passed in transaction's oncomplete event\r\n        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);\r\n        var store = self.db.transaction([entitySet.tableName], self.IDBTransactionType.READ_ONLY).setCallbacks({\r\n            onerror: callBack.error,\r\n            onabort: callBack.error,\r\n            oncomplete: function (event) {\r\n                if (self.operationProvider) {\r\n                    self.operationProvider.storageProvider.dataSource[entitySet.tableName] = query.rawDataList;\r\n                    self.operationProvider.storageProvider.executeQuery(query, {\r\n                        success: function (query) {\r\n                            if (query.expression.nodeType === $data.Expressions.ExpressionType.Count) {\r\n                                query.rawDataList[0] = { cnt: query.rawDataList[0] };\r\n                            }\r\n                            callBack.success(query);\r\n                        },\r\n                        error: callBack.error\r\n                    });\r\n                } else {\r\n                    callBack.success(query);\r\n                }\r\n            }\r\n        }).objectStore(entitySet.tableName);\r\n        var modelBinderCompiler = Container.createModelBinderConfigCompiler(query, []);\r\n        modelBinderCompiler.Visit(query.expression);\r\n\r\n        if (self.operationProvider) {\r\n            store.openCursor().onsuccess = function (event) {\r\n                // We currently support only toArray() so let's just dump all data\r\n                var cursor = event.target.result;\r\n                if (cursor) {\r\n                    var value = cursor.value;\r\n                    query.rawDataList.push(cursor.value);\r\n                    cursor['continue']();\r\n                }\r\n            };\r\n        } else {\r\n            switch (query.expression.nodeType) {\r\n                case $data.Expressions.ExpressionType.Count:\r\n                    store.count().onsuccess = function (event) {\r\n                        var count = event.target.result;\r\n                        query.rawDataList.push({ cnt: count });\r\n                    }\r\n                    break;\r\n                default:\r\n                    store.openCursor().onsuccess = function (event) {\r\n                        // We currently support only toArray() so let's just dump all data\r\n                        var cursor = event.target.result;\r\n                        if (cursor) {\r\n                            var value = cursor.value;\r\n                            query.rawDataList.push(cursor.value);\r\n                            cursor['continue']();\r\n                        }\r\n                    };\r\n                    break;\r\n            }\r\n        };\r\n    },\r\n    _getKeySettings: function (memDef) {\r\n        /// <summary>\r\n        /// Gets key settings for item type's member definition\r\n        /// </summary>\r\n        /// <param name=\"memDef\">memDef of item</param>\r\n        /// <returns>KeySettings object</returns>\r\n        var self = this;\r\n        var settings = { autoIncrement: false };\r\n        var keys = [];\r\n        memDef.PhysicalType.memberDefinitions\r\n            .getPublicMappedProperties().forEach(function (item) {\r\n                if (item.key) {\r\n                    // We found a key\r\n                    keys.push(item.name);\r\n                }\r\n                if (item.computed) {\r\n                    // AutoIncrement field, must be key\r\n                    if (!item.key)\r\n                        Guard.raise(new Exception('Only key field can be a computed field!'));\r\n\r\n                    var typeName = Container.resolveName(item.type);\r\n                    if (self.supportedAutoincrementKeys[typeName] === true) {\r\n                        settings.autoIncrement = true;\r\n                    }\r\n                }\r\n            });\r\n        if (keys.length > 1) {\r\n            if (settings.autoIncrement)\r\n                Guard.raise(new Exception('Auto increment is only valid for a single key!'));\r\n            // Setting key fields (composite key)\r\n            settings.keys = keys;\r\n        } else if (keys.length == 1) {\r\n            // Simple key\r\n            settings.keyPath = keys[0];\r\n        } else {\r\n            Guard.raise(new Exception('No valid key found!'));\r\n        }\r\n        return settings;\r\n    },\r\n    saveChanges: function (callBack, changedItems) {\r\n        var self = this;\r\n        // Building independent blocks and processing them sequentially\r\n        var independentBlocks = self.buildIndependentBlocks(changedItems);\r\n        function saveNextIndependentBlock() {\r\n            /// <summary>\r\n            /// Saves the next independent block\r\n            /// </summary>\r\n            if (independentBlocks.length === 0) {\r\n                // No more blocks left, calling success callback\r\n                callBack.success();\r\n            } else {\r\n                // 'Popping' next block\r\n                var currentBlock = independentBlocks.shift();\r\n                // Collecting stores of items for transaction initialize\r\n                var storesObj = {};\r\n                // Generating physicalData\r\n                var convertedItems = currentBlock.map(function (item) {\r\n                    storesObj[item.entitySet.tableName] = true;\r\n                    item.physicalData = {};\r\n                    item.entitySet.elementType.memberDefinitions\r\n                        .getPublicMappedProperties().forEach(function (memDef) {\r\n                            var typeName = Container.resolveName(memDef.type);\r\n                            if (memDef.key && memDef.computed && item.data[memDef.name] == undefined) {\r\n                                if (typeof self.supportedAutoincrementKeys[typeName] === 'function') {\r\n                                    var keyValue = self.supportedAutoincrementKeys[typeName]();\r\n                                    item.data[memDef.name] = self.fieldConverter.toDb[typeName](keyValue);\r\n                                } else {\r\n                                    // Autogenerated fields for new items should not be present in the physicalData\r\n                                    return;\r\n                                }\r\n                            }\r\n                            if (!memDef.inverseProperty && typeof memDef.concurrencyMode === 'undefined' && (memDef.key === true || item.data.entityState === $data.EntityState.Added || (item.data.changedProperties && item.data.changedProperties.some(function (def) { return def.name === memDef.name; })))) {\r\n                                if (self.fieldConverter.toDb[typeName]) {\r\n                                    item.physicalData[memDef.name] = self.fieldConverter.toDb[typeName](item.data[memDef.name]);\r\n                                } else {\r\n                                    var value = item.data[memDef.name];\r\n                                    if (value !== undefined) {\r\n                                        value = JSON.parse(JSON.stringify(value));\r\n                                    } \r\n                                    item.physicalData[memDef.name] = value;\r\n                                }\r\n                            }\r\n                        });\r\n                    return item;\r\n                });\r\n                var stores = [];\r\n                for (var i in storesObj) {\r\n                    stores.push(i);\r\n                }\r\n                var tran = self.db.transaction(stores, self.IDBTransactionType.READ_WRITE).setCallbacks({\r\n                    onerror: function (event) {\r\n                        // Only call the error callback when it's not because of an abort\r\n                        // aborted cases should call the error callback there\r\n                        if (!event.target || !self.IDBDatabaseException || (event.target && self.IDBDatabaseException && event.target.errorCode !== self.IDBDatabaseException.ABORT_ERR))\r\n                            callBack.error(event);\r\n                    },\r\n                    oncomplete: function (event) {\r\n                        // Moving to next block\r\n                        saveNextIndependentBlock();\r\n                    }\r\n                });\r\n                function KeySettingsCache() {\r\n                    /// <summary>\r\n                    /// Simple cache for key settings of types\r\n                    /// </summary>\r\n                    var cache = {};\r\n                    this.getSettingsForItem = function (item) {\r\n                        var typeName = item.data.getType().fullName;\r\n                        if (!cache.hasOwnProperty(typeName)) {\r\n                            cache[typeName] = self._getKeySettings(self.context._storageModel.getStorageModel(item.data.getType()));\r\n                        }\r\n                        return cache[typeName]\r\n                    }\r\n                }\r\n                var ksCache = new KeySettingsCache();\r\n                convertedItems.forEach(function (item) {\r\n                    // Getting store and keysettings for the current item\r\n                    var store = tran.objectStore(item.entitySet.tableName);\r\n                    var keySettings = ksCache.getSettingsForItem(item);\r\n                    // Contains the keys that should be passed for create, update and delete (composite keys)\r\n                    var itemKeys = keySettings.keys && keySettings.keys.map(function (key) { return item.physicalData[key]; }) || null;\r\n                    try {\r\n                        var cursorAction = function (action) {\r\n                            /// <summary>\r\n                            /// Find the current item in the store, and calls the action on it. Error raised when item was not found\r\n                            /// </summary>\r\n                            /// <param name=\"action\">Action to call on the item</param>\r\n                            var key = keySettings.keyPath ? item.physicalData[keySettings.keyPath] : itemKeys;\r\n                            var data = item.physicalData;\r\n                            store.openCursor(self.IDBKeyRange.only(key))\r\n                                .onsuccess = function (event) {\r\n                                    try {\r\n                                        var cursor = event.target.result;\r\n                                        if (cursor)\r\n                                            action(cursor, key, data);\r\n                                        else\r\n                                            Guard.raise(new Exception('Object not found', null, item));\r\n                                    } catch (ex) {\r\n                                        tran.abort();\r\n                                        callBack.error(ex);\r\n                                    }\r\n                                }\r\n                        };\r\n                        switch (item.data.entityState) {\r\n                            case $data.EntityState.Added:\r\n                                if (!keySettings.keyPath) {\r\n                                    // Item needs explicit keys\r\n                                    store.add(item.physicalData, itemKeys);\r\n                                }\r\n                                else {\r\n                                    store.add(item.physicalData)\r\n                                        .onsuccess = function (event) {\r\n                                            // Saves the generated key back to the entity\r\n                                            item.data[keySettings.keyPath] = event.target.result;\r\n                                        };\r\n                                }\r\n                                break;\r\n                            case $data.EntityState.Deleted:\r\n                                // Deletes the item\r\n                                cursorAction(function (cursor) {\r\n                                    cursor['delete']();\r\n                                });\r\n                                break;\r\n                            case $data.EntityState.Modified:\r\n                                // Updates the item\r\n                                cursorAction(function (cursor, key, data) {\r\n                                    cursor.update($data.typeSystem.extend(cursor.value, data));\r\n                                });\r\n                                break;\r\n                            case $data.EntityState.Unchanged:\r\n                                break;\r\n                            default:\r\n                                Guard.raise(new Exception('Not supported entity state', null, item));\r\n                        }\r\n                    } catch (ex) {\r\n                        // Abort on exceptions\r\n                        tran.abort();\r\n                        callBack.error(ex);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        saveNextIndependentBlock();\r\n    },\r\n    _compile: function (query) {\r\n        var sqlText = Container.createIndexedDBCompiler().compile(query);\r\n        return sqlText;\r\n    }\r\n}, {\r\n    isSupported: {\r\n        get: function () {\r\n            return $data.__global.indexedDB || $data.__global.webkitIndexedDB || $data.__global.mozIndexedDB || $data.__global.msIndexedDB ? true : false;\r\n        },\r\n        set: function () { }\r\n    }\r\n});\r\n\r\nif ($data.storageProviders.indexedDb.IndexedDBStorageProvider.isSupported)\r\n    $data.StorageProviderBase.registerProvider('indexedDb', $data.storageProviders.indexedDb.IndexedDBStorageProvider);\r\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _core = require('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _IndexedDBConverter = require('./IndexedDBConverter.js');\n\nvar _IndexedDBConverter2 = _interopRequireDefault(_IndexedDBConverter);\n\nvar _IndexedDBStorageProvider = require('./IndexedDBStorageProvider.js');\n\nvar _IndexedDBStorageProvider2 = _interopRequireDefault(_IndexedDBStorageProvider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _core2.default;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbXX0="],"sourceRoot":"/source/"}